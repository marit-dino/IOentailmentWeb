<div class="text-center">
  <h2>Entailment-Problem Solver</h2>
  <h4>for the original Input/Output Logics and their causal counterparts.</h4>
</div>

<app-entailment></app-entailment>


<div class="container text-container">
  <p>
    Using a SAT-Solver this program efficiently solves the entailment problem for the Input/Output Logics
    OUT <sub>1</sub>, OUT  <sub>2</sub>, OUT  <sub>3</sub>, OUT  <sub>4</sub> and their causal counterparts
    OUT <sub>1</sub> <sup> ⊥ </sup>, OUT <sub>2</sub> <sup> ⊥ </sup>, OUT <sub>3</sub> <sup> ⊥ </sup>,  OUT <sub>4</sub> <sup> ⊥ </sup>.
    For more information on the theoretical background see
    <a href="https://proceedings.kr.org/2023/15/">"Streamlining Input/Output Logics with Sequent Calculi" </a> by Ciabattoni and Rozplokhas.
  </p>
  <span class="fw-bold"> Instructions: </span>
  <ul>
    <li>
      Enter the deriving pairs (optional)
    </li>
    <li>
      Enter the goal pair
    </li>
    <li>
      Choose the I/O Logic
    </li>
    <li>
      Press Solve or Enter
    </li>
  </ul>

  <br>
  The goal and the deriving pairs have to be in the following EBNF-grammar, whitespace is ignored:<br><br>

  &lt;GoalPair&gt; ::= &lt;Pair&gt; <br>
  &lt;DerivingPairs&gt; ::= (&lt;Pair&gt; ("," &lt;Pair&gt;)*)? <br>
  &lt;Pair&gt; ::= "(" &lt;Formula&gt; "," &lt;Formula&gt; ")"<br>
  &lt;Formula&gt; ::= &lt;Var&gt; | &lt;TruthValue&gt; | &lt;UnaryOperation&gt; | "(" &lt;BinaryOperation&gt; ")"<br>
  &lt;BinaryOperation&gt; ::= &lt;Conjunction&gt; | &lt;Disjunction&gt; | &lt;Implication&gt; | &lt;Equivalence&gt;<br>
  &lt;Conjunction&gt; ::= &lt;Formula&gt; "&" &lt;Formula&gt;<br>
  &lt;Disjunction&gt; ::= &lt;Formula&gt; " | " &lt;Formula&gt;<br>
  &lt;Implication&gt; ::= &lt;Formula&gt; "-&gt;" &lt;Formula&gt;<br>
  &lt;Equivalence&gt; ::= &lt;Formula&gt; "&lt;-&gt;" &lt;Formula&gt;<br>
  &lt;UnaryOperator&gt; ::= &lt;Negation&gt;<br>
  &lt;Negation&gt; ::= "~" &lt;Formula&gt;<br>
  &lt;Var&gt; ::= (["a"-"z","A"-"E", "G"-"S", "U"-"Z", "_", "0" - "9"])+<br>
  &lt;TruthValue&gt; ::= &lt;True&gt; | &lt;False&gt;<br>
  &lt;True&gt; ::= "T"<br>
  &lt;False&gt; ::= "F"<br><br>
  Example for a goal pair: ((w1 & w2), (~e -&gt; (a &lt;-&gt; b)))<br>
  Example for deriving pairs: ((w1 & w2), (~e -&gt; (a &lt;-&gt; b))), (A, B), (~C, (e | (w1 &lt;-&gt; w2)))<br>

<br><br>
  <p>
    <span class="fw-bold">Countermodels and validity:</span><br>
    A countermodel is an I/O model (In, out) in which all the deriving pairs are valid but the goal pair is not.
    Each logic has certain conditions regarding the size of the input set <span class="fst-italic">In</span> of the I/O model.
    In the case of OUT <sub>1</sub>, OUT  <sub>2</sub>, OUT <sub>1</sub> <sup> ⊥ </sup>, OUT <sub>2</sub> <sup> ⊥ </sup>
    valid refers to 1-2-validity.
    And for OUT <sub>3</sub>, OUT  <sub>4</sub>, OUT <sub>3</sub> <sup> ⊥ </sup>, OUT <sub>4</sub> <sup> ⊥ </sup>
    valid refers to 3-4-validity.
  </p>
  <ul>
    <li>
      An I/O pair (A, X) is 1-2-valid in an I/O model (In, out) if (∀in ∈ In. in ⊨ A) implies out ⊨ X
      (<a href="https://proceedings.kr.org/2023/15/">Ciabattoni & Rozplokhas</a>, 2023, p. 6).
    </li>
    <li>
      An I/O pair (A, X) is 3-4-valid in an I/O model (In, out) if (∀in ∈ In. in ⊨ A) implies (∀w ∈ &#123;out&#125; ∪ In. w ⊨ X)
      (<a href="https://proceedings.kr.org/2023/15/">Ciabattoni & Rozplokhas</a>, 2023, p. 7).
    </li>
  </ul>
  If in a causal I/O logic the entailment of a goal pair from the set of deriving pairs is given ((A<sub>1</sub>, X<sub>1</sub>), ..., (A<sub>n</sub>, X<sub>n</sub>) ⊢ <sub> OUT <sub>k</sub> <sup> ⊥ </sup></sub> (B, Y))
  and X<sub>1</sub>, ..., X<sub>n</sub> ⊨ Y holds,
  then the deriving pairs also entail the goal pair in the corresponding original I/O logic.
  For more information see <a href="https://proceedings.kr.org/2023/15/">"Streamlining Input/Output Logics with Sequent Calculi" </a> by Ciabattoni and Rozplokhas.

</div>
